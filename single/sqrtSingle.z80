;Uses 3 bytes at scrap
sqrtSingle:
;733+2{0,15}+{0,1}+7{0,6}+{0,3}+pushpop+sqrtHL+2*HL_Div_E_special
;min: 1751
;max: 1985
;avg: 1856.5
  call pushpop
  push bc
  ld c,(hl)
  inc hl
  ld e,(hl)
  inc hl
  ld a,(hl)
  add a,a
  jp c,sqrtSingle_NaN
  scf
  rra
  ld d,a
  inc hl
  ld a,(hl)
  or a
  jp z,sqrtSingle_special
  add a,80h
  rra
  push af   ;new exponent
  jr c,+_
  srl d
  rr e
  rr c
_:
  ex de,hl
  ;HLC
  push bc
  call sqrtHL
  pop bc
  ld (scrap+2),a
  rr h
  ld h,l
  rr h
  ld l,c
  rr l
  ld e,a
  ;HL/E
  call HL_Div_E_special
  ld e,a
  ld a,c
  rra
  rl e
  ld d,0
  ld b,d
  rl d

  ld a,l
  ld (scrap+1),a



;now we need to compute l*l
  ld c,l
  ld l,b
  add a,a
  ld h,a
  jr nc,$+3 \ ld l,c
  add hl,hl \ jr nc,$+3 \ add hl,bc
  add hl,hl \ jr nc,$+3 \ add hl,bc
  add hl,hl \ jr nc,$+3 \ add hl,bc
  add hl,hl \ jr nc,$+3 \ add hl,bc
  add hl,hl \ jr nc,$+3 \ add hl,bc
  add hl,hl \ jr nc,$+3 \ add hl,bc
  add hl,hl \ jr nc,$+3 \ add hl,bc
;leaves c flag reset

;now need to perform DE*256-HL --> AHL
  xor a
  sub l
  ld l,a
  ld a,e
  sbc a,h
  ld h,a
  ld a,d
  sbc a,0
;AHL is the new remainder
;Need to divide by 2, then divide by the 16-bit (var_x+4)
  push af
  rra
  rr h
  rr l
  inc a
  jr nz,+_
  sub l \ ld l,a
  sbc a,a \ sub h \ ld h,a
_:
  ld bc,(scrap+1)
;HL/BC to 8 bits, allowed to destroy remainder
;We are just going to approximate it
  ld e,b
  call HL_Div_E_special
  pop af
  pop de
  ld a,l
  pop hl
  jr nc,+_
  neg
  dec bc
_:
  ;DBCA
  ld (hl),a
  inc hl
  ld (hl),c
  inc hl
  res 7,b
  ld (hl),b
  inc hl
  ld (hl),d
  ret
sqrtSingle_NaN:
  ld hl,const_NaN
  pop de
  jp mov4
sqrtSingle_special:
  dec hl
  dec hl
  pop de
  jp mov4
HL_Div_E_special:
;262+7{0,3+{0,3}}+{8,{0,12}}
;min: 262cc
;max: 316cc
;avg: 284.75cc
  ld a,h
  sla l \ rla \ jr c,$+5 \ cp e \ jr c,$+4 \ sub e \ inc l
  sla l \ rla \ jr c,$+5 \ cp e \ jr c,$+4 \ sub e \ inc l
  sla l \ rla \ jr c,$+5 \ cp e \ jr c,$+4 \ sub e \ inc l
  sla l \ rla \ jr c,$+5 \ cp e \ jr c,$+4 \ sub e \ inc l
  sla l \ rla \ jr c,$+5 \ cp e \ jr c,$+4 \ sub e \ inc l
  sla l \ rla \ jr c,$+5 \ cp e \ jr c,$+4 \ sub e \ inc l
  sla l \ rla \ jr c,$+5 \ cp e \ jr c,$+4 \ sub e \ inc l
  sla l \ rla \ jr c,$+4 \ cp e \ ret c \ sub e \ inc l
  ret
sqrtHL:
;returns A as the sqrt, HL as the remainder, D = 0
;min: 376cc
;max: 416cc
;avg: 393cc
  ld de,$5040
  ld a,h
  sub e
  jr nc,+_
  add a,e
  ld d,$10
_:
  sub d
  jr nc,+_
  add a,d
  .db $01   ;start of ld bc,** which is 10cc to skip the next two bytes.
_:
  set 5,d
  res 4,d
  srl d

  set 2,d
  sub d
  jr nc,+_
  add a,d
  .db $01   ;start of ld bc,** which is 10cc to skip the next two bytes.
_:
  set 3,d
  res 2,d
  srl d

  inc d
  sub d
  jr nc,+_
  add a,d
  dec d   ;this resets the low bit of D, so `srl d` resets carry.
  .db $06   ;start of ld b,* which is 7cc to skip the next byte.
_:
  inc d
  srl d
  ld h,a


  sbc hl,de
  ld a,e
  jr nc,+_
  add hl,de
_:
  ccf
  rra
  srl d
  rra
  ld e,a

  sbc hl,de
  jr nc,+_
  add hl,de
  .db $01   ;start of ld bc,** which is 10cc to skip the next two bytes.
_:
  or %00100000
  xor %00011000
  srl d
  rra
  ld e,a


  sbc hl,de
  jr nc,+_
  add hl,de
  .db $01   ;start of ld bc,** which is 10cc to skip the next two bytes.
_:
  or %00001000
  xor %00000110
  srl d
  rra
  ld e,a
  sbc hl,de
  jr nc,+_
  add hl,de
  srl d
  rra
  ret
_:
  inc a
  srl d
  rra
  ret
mov4:
  ldi
  ldi
  ldi
  ldi
  ret
